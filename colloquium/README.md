## 1. WinAPI для решения лабораторной работы №2

Программа создаёт три потока: `main`, `min_max` и `average`. Используются **CreateThread**, **WaitForSingleObject**, **CloseHandle**, а также **CRITICAL_SECTION** для синхронизации данных.

### **Код на C++**

```cpp
#include <windows.h>
#include <stdio.h>

CRITICAL_SECTION cs; // Критическая секция

DWORD WINAPI min_max(LPVOID lpParam);
DWORD WINAPI average(LPVOID lpParam);

int main() {
    HANDLE hThread1, hThread2;
    DWORD ThreadID1, ThreadID2;

    InitializeCriticalSection(&cs);

    hThread1 = CreateThread(NULL, 0, min_max, NULL, 0, &ThreadID1);
    hThread2 = CreateThread(NULL, 0, average, NULL, 0, &ThreadID2);

    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    CloseHandle(hThread1);
    CloseHandle(hThread2);

    DeleteCriticalSection(&cs);
    return 0;
}

DWORD WINAPI min_max(LPVOID lpParam) {
    EnterCriticalSection(&cs);
    int numbers[] = {10, 4, 15, 23, 1, 7};
    int min = numbers[0], max = numbers[0];
    for (int i = 1; i < sizeof(numbers) / sizeof(numbers[0]); i++) {
        if (numbers[i] < min) min = numbers[i];
        if (numbers[i] > max) max = numbers[i];
    }
    printf("Min: %d, Max: %d\n", min, max);
    LeaveCriticalSection(&cs);
    return 0;
}

DWORD WINAPI average(LPVOID lpParam) {
    EnterCriticalSection(&cs);
    int numbers[] = {10, 4, 15, 23, 1, 7};
    int sum = 0, count = sizeof(numbers) / sizeof(numbers[0]);
    for (int i = 0; i < count; i++) {
        sum += numbers[i];
    }
    printf("Average: %.2f\n", (double)sum / count);
    LeaveCriticalSection(&cs);
    return 0;
}
```

---

## 2. Что такое процесс в ОС Windows?

**Процесс** — это исполняемая программа с собственным адресным пространством, ресурсами и одним или несколькими потоками.

Основные функции для работы с процессами:

- `CreateProcess()` — создание процесса.
- `TerminateProcess()` — завершение.
- `WaitForSingleObject()` — ожидание завершения процесса.
- `GetExitCodeProcess()` — получение кода завершения.

---

## 3. Критическая секция

**Критическая секция (Critical Section)** защищает ресурсы от одновременного доступа нескольких потоков.

Пример использования:

```cpp
CRITICAL_SECTION cs;

void function() {
    EnterCriticalSection(&cs);
    // Доступ к общему ресурсу
    LeaveCriticalSection(&cs);
}
```

---

## 4. Семафор

**Семафор (Semaphore)** ограничивает количество потоков, которым разрешён доступ к ресурсу.

Пример использования:

```cpp
HANDLE hSemaphore;

DWORD WINAPI ThreadFunction(LPVOID lpParam) {
    WaitForSingleObject(hSemaphore, INFINITE);
    // Работа с ресурсом
    ReleaseSemaphore(hSemaphore, 1, NULL);
    return 0;
}

int main() {
    hSemaphore = CreateSemaphore(NULL, 2, 2, NULL);
    // Создание потоков
    CloseHandle(hSemaphore);
    return 0;
}
```

---

## 5. Сравнительный анализ стандартов C++

### **C++98 vs современные стандарты**

| Возможность          | C++98                    | C++11+                               | Boost               | Qt                   |
| -------------------- | ------------------------ | ------------------------------------ | ------------------- | -------------------- |
| Умные указатели      | `std::auto_ptr` (устар.) | `std::unique_ptr`, `std::shared_ptr` | `boost::shared_ptr` | `QSharedPointer`     |
| Потоки               | Отсутствуют              | `std::thread`                        | `boost::thread`     | `QThread`            |
| Регулярные выражения | Отсутствуют              | `std::regex`                         | `boost::regex`      | `QRegularExpression` |
| Асинхронность        | `pthread`                | `std::async`, `std::future`          | `boost::asio`       | `QFuture`            |

### **Пример использования C++20 вместо Boost**

```cpp
#include <optional>
std::optional<int> getValue(bool flag) {
    return flag ? std::optional<int>(42) : std::nullopt;
}
```

В C++98 для этого использовался `boost::optional`.

---

## 1. Что такое ООП?

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, основанная на организации программы вокруг объектов, которые взаимодействуют друг с другом. Объекты представляют собой экземпляры классов и могут содержать данные (поля) и методы (функции).

### Основные принципы ООП:

- **Инкапсуляция** – процесс скрытия деталей реализации, предоставление только нужных интерфейсов для взаимодействия.
- **Наследование** – возможность создания нового класса на основе существующего, заимствуя его свойства и методы.
- **Полиморфизм** – способность объектов разных типов быть обработанными одинаково.
- **Абстракция** – выделение существенных характеристик объектов, игнорирование несущественных.

### Пример на C++:

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void makeSound() { cout << "Some sound\n"; }  // Полиморфизм
};

class Dog : public Animal {  // Наследование
public:
    void makeSound() override { cout << "Bark!\n"; }
};

int main() {
    Animal* a = new Dog();
    a->makeSound(); // Выведет "Bark!"
    delete a;
}
```

## 2. Магическое число 7 Миллера

Магическое число **7±2** было предложено Джорджем Миллером в 1956 году и относится к ограничению, которое человек может запомнить в своей рабочей памяти (около 7 элементов).

### 7 примеров из IT:

1. **7 уровней модели OSI**: физический, канальный, сетевой, транспортный, сеансовый, представления, приложения.
2. **7 регистров процессора x86**: EAX, EBX, ECX, EDX, ESI, EDI, EBP.
3. **7 слоев безопасности в кибербезопасности**.
4. **7-значные телефонные номера**.
5. **7 цветов в RGB 3-битной палитре**.
6. **7 уровней RAID-массивов** (RAID 0–6).
7. **7 элементов в URL-структуре**: схема, хост, порт, путь, параметры, запрос, фрагмент.

---

## 3. Энтропия ПО

**Энтропия ПО** – это мера неопределенности и сложности системы. Она увеличивается по мере добавления новых функций и изменений в программу, что затрудняет понимание и поддержку кода.

### 5 примеров мер, снижающих энтропию при разработке ПО:

1. **Модульность** – разделение программы на независимые модули для улучшения понимания и управления.
2. **Чистый код** – использование простых и понятных имен переменных, методов, классов.
3. **Автоматизация тестирования** – написание автоматизированных тестов, чтобы обеспечить стабильность кода при изменениях.
4. **Документация** – поддержание актуальной документации, что облегчает понимание и поддержку системы.
5. **Использование паттернов проектирования** – применение проверенных решений для типичных задач разработки, таких как Singleton, Factory, Observer и т.д.

---

## 4. 5 признаков сложной системы по Гради Бучу

Гради Буч в своей книге "Объектно-ориентированное проектирование" выделяет пять признаков сложной системы:

1. **Множество компонентов** – сложные системы состоят из множества отдельных частей, которые взаимодействуют друг с другом.

   - **Пример**: В проекте, связанном с обработкой данных, отдельные модули могут быть ответственны за загрузку данных, обработку и вывод, что приводит к необходимости взаимодействия между ними.

2. **Невозможность полного предсказания поведения системы** – из-за большого числа компонентов поведение системы может быть трудно предсказуемым.

   - **Пример**: Программа для анализа данных может вести себя по-разному в зависимости от размера входных данных.

3. **Многоуровневая архитектура** – сложные системы часто разделяются на несколько слоев, каждый из которых отвечает за разные аспекты работы.

   - **Пример**: Веб-приложение часто разделяется на слой представления, бизнес-логику и доступ к данным.

4. **Частая необходимость в изменениях** – сложные системы постоянно требуют изменений и обновлений для удовлетворения новых требований.

   - **Пример**: Веб-приложение с клиентом и сервером часто изменяется в ответ на обновления в браузерах или изменениях в API.

5. **Зависимости между компонентами** – в сложных системах компоненты могут зависеть друг от друга, что усложняет внесение изменений.
   - **Пример**: В многозадачных приложениях изменение одного модуля может потребовать изменений в других, что усложняет тестирование.

---

## 5. Закон иерархических компенсаций Седова

**Закон иерархических компенсаций Седова** предполагает, что в сложных системах элементы, взаимодействующие на разных уровнях иерархии, компенсируют друг друга для достижения общего эффекта.

### 5 исторических примеров применения закона Седова в эволюции IT сферы:

1. **Развитие операционных систем**: ОС сначала состояли из большого количества низкоуровневых функций, но с развитием иерархии управления на высоком уровне, все эти функции были инкапсулированы в ядро операционной системы.

2. **Роль API в веб-разработке**: Веб-сервисы стали абстрагировать сложные операции с базами данных и другими системами, предоставляя пользователям простой интерфейс для работы с ними.

3. **Микросервисная архитектура**: При переходе от монолитных приложений к микросервисам, каждый сервис компенсирует свою сложность за счет взаимодействия с другими сервисами.

4. **Использование облачных технологий**: Виртуализация и облачные вычисления компенсируют необходимость в управлении физическими серверами и позволяют быстрее масштабировать приложения.

5. **Технологии кеширования**: В системах с высокими нагрузками (например, веб-сервисы) используются технологии кеширования для компенсации запросов к базе данных, улучшая производительность.

```

```
